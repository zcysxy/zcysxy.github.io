<!DOCTYPE html>
<html>
  <head>
    <title>Research Dimensions</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <style>
      #info-card {
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 15px;
        padding-bottom: 0px;
        background-color: #f9f9f9;
        box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
      }
      #info-card h3 {
        margin-top: 0;
      }
    </style>
  </head>
  <body>
    <div id="myPlot" style="width: 750px; height: 600px"></div>
    <div
      id="info-card"
      style="width: 750px; margin-top: -60px; position: relative; z-index: 10"
    ></div>

    <script>
      // --- AXIS LINE DATA ---
      var axisLineColor = "#333";
      var axisLineWidth = 7;
      var arrowColor = "#333";
      var arrowSizeRef = 0.8;

      // X-Axis line
      var xAxisLine = {
        type: "scatter3d",
        mode: "lines",
        x: [0, 10],
        y: [0, 0],
        z: [0, 0],
        line: { color: axisLineColor, width: axisLineWidth },
        showlegend: false,
      };
      // Y-Axis line
      var yAxisLine = {
        type: "scatter3d",
        mode: "lines",
        x: [0, 0],
        y: [0, 10],
        z: [0, 0],
        line: { color: axisLineColor, width: axisLineWidth },
        showlegend: false,
      };
      // Z-Axis line
      var zAxisLine = {
        type: "scatter3d",
        mode: "lines",
        x: [0, 0],
        y: [0, 0],
        z: [-1, 1],
        line: { color: axisLineColor, width: axisLineWidth },
        showlegend: false,
      };

      // --- ARROWHEAD DATA (Cones) ---
      // X-Axis Arrowhead
      var xAxisArrow = {
        type: "cone",
        x: [10],
        y: [0],
        z: [0],
        u: [1],
        v: [0],
        w: [0],
        sizemode: "absolute",
        sizeref: arrowSizeRef,
        showscale: false,
        colorscale: [
          [0, arrowColor],
          [1, arrowColor],
        ],
        showlegend: false,
      };
      // Y-Axis Arrowhead
      var yAxisArrow = {
        type: "cone",
        x: [0],
        y: [10],
        z: [0],
        u: [0],
        v: [1],
        w: [0],
        sizemode: "absolute",
        sizeref: arrowSizeRef,
        showscale: false,
        colorscale: [
          [0, arrowColor],
          [1, arrowColor],
        ],
        showlegend: false,
      };
      // Z-Axis Arrowhead
      var zAxisArrow = {
        type: "cone",
        x: [0],
        y: [0],
        z: [1],
        u: [0],
        v: [0],
        w: [1],
        sizemode: "absolute",
        sizeref: arrowSizeRef / 5,
        showscale: false,
        colorscale: [
          [0, arrowColor],
          [1, arrowColor],
        ],
        showlegend: false,
      };
      var zAxisArrowNeg = {
        type: "cone",
        x: [0],
        y: [0],
        z: [-1],
        u: [0],
        v: [0],
        w: [-1],
        sizemode: "absolute",
        sizeref: arrowSizeRef / 5,
        showscale: false,
        colorscale: [
          [0, arrowColor],
          [1, arrowColor],
        ],
        showlegend: false,
      };

      // --- CUSTOM DATA POINTS (Split for Legend) ---
      const points = [
        {
          x: 4,
          y: 8,
          z: 1,
          label: "Preprint'25",
          legend: "Personalized Collaborative Learning",
          color: "#d62728",
          title:
            "Personalized Collaborative Learning with Affinity-Based Variance Reduction",
          authors: "<strong>Chenyu Zhang</strong> and Navid Azizan",
          summary:
            "We show that collaboration between arbitrarily heterogeneous agents can yield fully personalized solutions with an adaptive, affinity-based speedup.",
          keywords: [
            "heterogeneity",
            "personalization",
            "collaboration",
            "control variates",
            "variance reduction",
          ],
        },
        {
          x: 4,
          y: 2,
          z: 1,
          label: "ICLR'24",
          legend: "Federated Reinforcement Learning",
          color: "#1f77b4",
          title:
            "Finite-Time Analysis of On-Policy Heterogeneous Federated Reinforcement Learning",
          authors:
            "<strong>Chenyu Zhang</strong>, Han Wang, Aritra Mitra, and James Anderson",
          summary:
            "An agent can expedite the process of learning its own near-optimal policy by leveraging information from other agents with potentially different environments.",
          keywords: [ "heterogeneity", "federated reinforcement learning", "non-stationary Markov chain",
          ],
        },
        {
          x: 9,
          y: 0,
          z: -0.9,
          label: "ECAI'24",
          legend: "Mean Field Game",
          color: "#2ca02c",
          title: "A Single Online Agent Can Efficiently Learn Mean Field Games",
          authors: "<strong>Chenyu Zhang</strong>, Xu Chen, and Xuan Di",
          summary:
            "A single online agent can efficiently learn the equilibria of mean field games.",
          keywords: [
            "mean field game",
            "online learning",
          ],
        },
        {
          x: 10,
          y: 0,
          z: -1,
          label: "ICLR'25",
          color: "#2ca02c",
          title:
            "Stochastic Semi-Gradient Descent for Learning Mean Field Games with Population-Aware Function Approximation",
          authors: "<strong>Chenyu Zhang</strong>, Xu Chen, and Xuan Di",
          summary:
            "A simple SGD-type method can we learn mean field games with a large and even continuous state-action space without a forward-backward process.",
          keywords: [
            "mean field game",
            "online learning",
            "function approximation",
						"asynchronous learning",
          ],
        },
        {
          x: 10,
          y: 9,
          z: -1,
          label: "ICML'25",
          legend: "Graphon Game",
          color: "#ff7f0e",
          title:
            "Graphon Mean Field Games with a Representative Player: Analysis and Learning Algorithm",
          authors:
            "Fuzhong Zhou, <strong>Chenyu Zhang</strong>, Xu Chen, and Xuan Di",
          summary:
            "We analyze and learn graphon games with discontinuous graphons.",
          keywords: ["heterogeneity", "graphon game", "online learning"],
        },
      ];

      const dataPointTraces = points.flatMap((point) => [
        {
          // This trace is for the marker and legend entry
          type: "scatter3d",
          mode: "markers",
          x: [point.x],
          y: [point.y],
          z: [point.z],
          name: point.legend,
          marker: {
            size: 8,
            color: point.color,
            symbol: "circle",
            line: { width: 0, color: point.color },
          },
          showlegend: !!point.legend,
        },
        {
          // This trace is for the text label only
          type: "scatter3d",
          mode: "text",
          x: [point.x],
          y: [point.y],
          z: [point.z],
          text: [point.label],
          textfont: { color: point.color, size: 10 },
          textposition: "middle right",
          showlegend: false, // Never show text in legend
        },
      ]);

      // --- NEW: 3D TEXT LABELS (Split by Axis) ---
      var labelFont = { color: "#555", size: 10 };
      var titleFont = { color: "black", size: 12, weight: "bold" };

      // X-Axis Labels
      var xTickLabels = {
        type: "scatter3d",
        mode: "text",
        showlegend: false,
        textfont: labelFont,
        x: [5, 9],
        y: [-1, -1],
        z: [0, 0],
        text: ["N", "âˆž"],
      };
      var xAxisTitle = {
        type: "scatter3d",
        mode: "text",
        showlegend: false,
        textfont: titleFont,
        x: [12],
        y: [-1],
        z: [0],
        text: ["# of agents"],
      };

      // Y-Axis Labels
      var yTickLabels = {
        type: "scatter3d",
        mode: "text",
        showlegend: false,
        textfont: labelFont,
        x: [-1, -1, -1],
        y: [0, 2, 8],
        z: [0, 0, 0],
        text: ["homog.", "low", "high"],
      };
      var yAxisTitle = {
        type: "scatter3d",
        mode: "text",
        showlegend: false,
        textfont: titleFont,
        x: [-1],
        y: [11],
        z: [0],
        text: ["heterogeneity"],
      };

      // Z-Axis Labels
      var zTickLabels = {
        type: "scatter3d",
        mode: "text",
        showlegend: false,
        textfont: labelFont,
        x: [-1, -1],
        y: [1.2, 1],
        z: [-1, 0.8],
        text: ["compete", "collab"],
      };
      var zAxisTitle = {
        type: "scatter3d",
        mode: "text",
        showlegend: false,
        textfont: titleFont,
        x: [-1.5],
        y: [-1.5],
        z: [1],
        text: ["interaction"],
      };

      // Combine all traces into one data array
      var data = [
        xAxisLine,
        yAxisLine,
        zAxisLine,
        xAxisArrow,
        yAxisArrow,
        zAxisArrow,
        zAxisArrowNeg,
      ]
        .concat(dataPointTraces)
        .concat([
          // Add the new, separated label traces
          xTickLabels,
          xAxisTitle,
          yTickLabels,
          yAxisTitle,
          zTickLabels,
          zAxisTitle,
        ]);

      // --- LAYOUT ---

      var layout = {
        title: "Research Dimensions",
        showlegend: true,
        legend: {
          orientation: "v",
          // yanchor: "bottom",
          y: 0.5,
          // xanchor: "center",
          // x: 0.5,
        },

        scene: {
          // X-Axis: Hide default labels, keep range

          xaxis: {
            title: "", // <-- Hide default title
            range: [-2, 12],
            showticklabels: false, // <-- Hide default ticks
            showgrid: true,
            zeroline: false,
          },
          // Y-Axis: Hide default labels, keep range
          yaxis: {
            title: "", // <-- Hide default title
            range: [-2, 11],
            showticklabels: false, // <-- Hide default ticks
            showgrid: true,
            zeroline: false,
          },
          // Z-Axis: Hide default labels, keep range
          zaxis: {
            title: "", // <-- Hide default title
            range: [-1, 1],
            showticklabels: false, // <-- Hide default ticks
            showgrid: true,
            zeroline: false,
          },
        },
        margin: {
          l: 1,
          r: 1,
          b: 80,
          t: 40,
        },
      };

      // Create the plot
      Plotly.newPlot("myPlot", data, layout);

      // --- DYNAMIC LABEL VISIBILITY ---
      var myPlot = document.getElementById("myPlot");

      myPlot.on("plotly_relayout", function (eventdata) {
        // This event fires when the user rotates/zooms the 3D scene
        if (myPlot.layout.scene && myPlot.layout.scene.camera) {
          var eye = myPlot.layout.scene.camera.eye;

          // Normalize the camera position vector to ignore zoom level
          var mag = Math.sqrt(eye.x * eye.x + eye.y * eye.y + eye.z * eye.z);
          if (mag === 0) return; // Avoid division by zero
          var normEye = { x: eye.x / mag, y: eye.y / mag, z: eye.z / mag };

          // Set a threshold for when an axis is considered "aligned" with the camera
          var threshold = 0.95; // Adjust for sensitivity

          // When the camera's normalized position has a large component in one direction
          // (e.g., abs(normEye.x) is close to 1), it means we are looking ALONG that axis.
          // In that case, we want to HIDE the labels. So, visibility is true when the
          // component is SMALLER than the threshold.
          var xLabelsVisible = Math.abs(normEye.x) < threshold;
          var yLabelsVisible = Math.abs(normEye.y) < threshold;
          var zLabelsVisible = Math.abs(normEye.z) < threshold;

          // Update the visibility of the corresponding traces using restyle.
          // Indices are based on the final `data` array order after splitting traces.
          // 3: xAxisArrow
          // 4: yAxisArrow
          // 5: zAxisArrow, 6: zAxisArrowNeg
          // 17: xTickLabels, 18: xAxisTitle
          // 19: yTickLabels, 20: yAxisTitle
          // 21: zTickLabels, 22: zAxisTitle
          Plotly.restyle(myPlot, { visible: xLabelsVisible }, [3, 17, 18]);
          Plotly.restyle(myPlot, { visible: yLabelsVisible }, [4, 19, 20]);
          Plotly.restyle(myPlot, { visible: zLabelsVisible }, [5, 6, 21, 22]);
          // Only update grid if needed to avoid infinite loop
          var scene = myPlot.layout.scene;
          var needsUpdate =
            scene.xaxis.showgrid !== xLabelsVisible ||
            scene.yaxis.showgrid !== yLabelsVisible ||
            scene.zaxis.showgrid !== zLabelsVisible;

          if (needsUpdate) {
            Plotly.relayout(myPlot, {
              "scene.xaxis.showgrid": xLabelsVisible,
              "scene.yaxis.showgrid": yLabelsVisible,
              "scene.zaxis.showgrid": zLabelsVisible,
            });
          }
        }
      });

      document.getElementById("info-card").style.display = "none";
      // --- CLICK EVENT HANDLER ---
      myPlot.on("plotly_click", function (data) {
        var point = data.points[0];
        // We only want to show cards for our main data points, not axis lines etc.
        // The customdata is not directly available on the point, so we check the curveNumber
        // to see if it's one of the dataPointTraces.
        // dataPointTraces start after the 7 axis-related traces.
        if (
          point.curveNumber >= 7 &&
          point.curveNumber < 7 + dataPointTraces.length
        ) {
          var pointIndex = Math.floor((point.curveNumber - 7) / 2); // Each point has a marker and a text trace
          var originalPointData = points[pointIndex];
          Plotly.restyle(
            myPlot,
            { opacity: 0.4 },
            points.map((_, i) => i * 2 + 7)
          );
          Plotly.restyle(myPlot, { opacity: 1.0 }, [7 + pointIndex * 2]); // Highlight selected point

          var card = document.getElementById("info-card");
          card.innerHTML = `
            <h3>${originalPointData.title || "Selected Point"}</h3>
            <p>${originalPointData.authors}</p>
						<p><em>${originalPointData.label}</em></p>
						<p>
<strong>Keywords</strong>: ${originalPointData.keywords.join(", ")}</br>
						<strong>Takeaway</strong>: ${originalPointData.summary}
						</p>
          `;
          card.style.display = "block";
        } else {
          // Hide card if not a data point
          document.getElementById("info-card").style.display = "none";
          Plotly.restyle(
            myPlot,
            { opacity: 1.0 },
            points.map((_, i) => i * 2 + 7)
          );
        }
      });
    </script>
  </body>
</html>
